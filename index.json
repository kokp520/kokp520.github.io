[{"categories":["Documents"],"content":"教學要怎麼建立自己的 hugo 靜態網站 + github.io ","date":"2023-08-26","objectID":"/adi-website/:0:0","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"如何建立 hugo 個人靜態網站 ","date":"2023-08-26","objectID":"/adi-website/:1:0","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"Hugo installation 由於我個人是屬於 Mac 使用者，所以就跟 window 使用者說抱歉了～ 😲 brew install hugo 檢查 執行hugo --version，如果有出現版本，代表成功安裝。 ","date":"2023-08-26","objectID":"/adi-website/:1:1","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"Create local file hugo new site myWebsite 你會看到資料夾內多了myWebsite的檔案 / ├── archetypes ├── assets ├── content ├── data ├── layouts ├── resources ├── static ├── public ├── themes ├── hugo.html ☝️ 架構與作用會類似長得像這樣 ☝️ 每個資料夾大致作用 archetypes - 默認的文件，Hugo 會根據這裡的模型來生成內容 assets - hugo 資源文件，像是 scss/sass,typescript 等，hugo 會將他們編譯成靜態資源 content - 網站的內容頁面，也就是你的文章。 data - 網站會需要的數據，像是 json,yaml,toml layouts - hugo 模板文件，決定內容如何編譯成 html，像是你的首頁 resoutces - hugo 處理後的資源文件 static - 靜態文件圖片，會直接複製到 public public - hugo 生成的整個網站輸出目錄。 github.io 就要存放在這裡 theme - 主題 hugo.html - website 設定檔 簡單來說，hugo 根據content and data 生成頁面，layout控制渲染，assets and resources處理資源，public輸出文件目錄。 ","date":"2023-08-26","objectID":"/adi-website/:1:2","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"Theme hugo 本身有建立許多主題的分享 我個人是會把主題的作者附在個人的網站上，尊重每個創作者！ 可以從這裡下載 - hugo theme hugo theme 點擊喜歡的主題後你會看到有 Download 大部分的主題也都會有 Demo，挑自己喜歡的就可以了。 demo 點擊demo的超連結就可以了 Note 通常每個主題內部都會在教學如何安裝，可能會有些許不同。 如果有遇到問題可以到該主題的 github 觀看！ 關於git的指令我之後再寫一篇文章講解 在你下載的主題之中會有exampleSite，把他複製下來貼到有go.mod那一頁。 go.mod 或是你可以直接把你需要的exampleSite/content, static等出來讓模板渲染他，這些都只是範例但你可以依照自己想法去慢慢編輯。 * (畢竟刪除比加法簡單) ","date":"2023-08-26","objectID":"/adi-website/:1:3","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"開啟 local server 接下來你可以在有go.mod那一頁執行 hugo server hugo server 這邊的localhost:54104 可以直接按者Ctrl+左鍵點擊他 就可以看到妳美美的網站了! 再去你的設定檔以及content/posts內部慢慢上傳貼文了～ ","date":"2023-08-26","objectID":"/adi-website/:1:4","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"發佈到 github 首先我個人會在 github 建立兩個 repo，一個存放靜態網頁，一個存放自己的文件內容。 先假設你是在~/中執行， # 創立兩個資料夾 mkdir myWebsite # 這邊會存放有著go.mod的內容 也就是上方做的資料 mkdir public # 這邊把靜態檔案跟主檔案切開 Step 1 - 在 github 上建立兩個 repo，一個叫做 myWebsite(這邊沒有特別指定名稱)，第二個必須要叫做github帳號.github.io，github Page 才會讀取你的靜態網頁。 Step 2 - 在有 go.mod 的專案底下 cd ~/myWebsite git init git remote add origin https://github.com/帳號/網站專案名稱 git add . git commit -m 'create project' git push origin main Step 3 - 在public，執行 cd ~/public git init git remote add origin https://github.com/帳號/帳號.github.io git add . git commit -m 'create github page' git push origin main Step 4 - 再回到有 go.mod 的頁面 建立一個捷徑到你的 myWebsite #複製你的public絕對路徑 以我的mac舉例 ln -s /home/user/public /home/user/myWebsite Step 5 - 回到 myWebsite 後執行hugo cd ~/myWebsite; hugo; # 這時會建立靜態檔案到public裡 #回到public push 到github就完成了 cd ~/public git add . git ci -m 'add static website' git push origin main 恭喜你完成部署自己的網站！ 再來就到https://帳號.github.io就可以看到你的個人網站了 Tip 部署會需要一些時間，想知道 CI/CD 發生什麼事，可以到 github.io 的 repo 點擊 action 就可以看到 action.png ","date":"2023-08-26","objectID":"/adi-website/:1:5","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"建立貼文 有人問我說要怎麼創建貼文，只要到你的myWebsite/content/posts/創建 postName/index.md ","date":"2023-08-26","objectID":"/adi-website/:1:6","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"hackMD md 是什麼？ 這已經不是本文章的內容了在這邊分享一些連結 😆 Markdown 語法大全 hackmd hackmd 練習 👆 可以在這邊創建帳號，就可以直接寫 markdown 且執行展示給你看！ ","date":"2023-08-26","objectID":"/adi-website/:1:7","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"CI/CD Script tool 另外分享個執行部屬的腳本 package main import ( \"fmt\" \"os\" \"os/exec\" \"path/filepath\" ) func main() { // 設定 Hugo 專案目錄的路徑 hugoProjectPath := \"你的public的絕對路徑\" hugoPath := \"有go.mod的那個repo路徑\" // ----- website content ----- // 執行 Git 命令 if err := executeCommands(hugoPath, \"git\", \"add\", \".\"); err != nil { fmt.Println(\"Git add 失敗:\", err) return } if err := executeCommands(hugoPath, \"git\", \"commit\", \"-m\", \"update new post\"); err != nil { fmt.Println(\"Git commit 失敗:\", err) return } if err := executeCommands(hugoPath, \"git\", \"push\"); err != nil { fmt.Println(\"Git push 失敗:\", err) return } fmt.Println(\"hugo path完成！\") // ---- public ----- // 執行 Hugo 命令 if err := executeCommand(hugoPath, \"hugo\"); err != nil { fmt.Println(\"Hugo 執行失敗:\", err) return } // 執行 Git 命令 if err := executeCommands(hugoProjectPath, \"git\", \"add\", \".\"); err != nil { fmt.Println(\"Git add 失敗:\", err) return } if err := executeCommands(hugoProjectPath, \"git\", \"commit\", \"-m\", \"update\"); err != nil { fmt.Println(\"Git commit 失敗:\", err) return } if err := executeCommands(hugoProjectPath, \"git\", \"push\"); err != nil { fmt.Println(\"Git push 失敗:\", err) return } fmt.Println(\"完成！\") } func executeCommand(dir, command string, args ...string) error { cmd := exec.Command(command, args...) cmd.Dir = dir cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr return cmd.Run() } func executeCommands(dir, command string, args ...string) error { cmd := exec.Command(command, args...) cmd.Dir = dir cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr return cmd.Run() } func getAbsolutePath(relativePath string) (string, error) { absPath, err := filepath.Abs(relativePath) if err != nil { return \"\", err } return absPath, nil } 執行方法 # 我個人是放在有go.mod的那個目錄創建bin資料夾，把上面的code放在裡面 go run bin/cicd_script.go 就可以瞜！ ","date":"2023-08-26","objectID":"/adi-website/:1:8","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["Documents"],"content":"調整網頁細項 todo comming soon… ","date":"2023-08-26","objectID":"/adi-website/:2:0","tags":[],"title":"如何建立個人靜態網站 - Hugo","uri":"/adi-website/"},{"categories":["project"],"content":"使用Nodejs+express開發購物網站","date":"2023-08-26","objectID":"/oldroad-website/","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"OldroadWebsite | SHOP | Nodejs | Express | MongoDB 使用Nodejs+express開發購物網站，包含登入系統、後台系統、購物車系統。 Old-Road Shop ","date":"2023-08-26","objectID":"/oldroad-website/:0:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Introduction This project was completed before i enter the software industry. At that time, I created a website as a side bussiness venture for selling like old school clothes, cause many of my friends in the unversity dance club are enthusiasts of vintage culture. However, it is no longer in use at the moment. Because A free acount of AWS EC2 and RDS is limited to a one year. LOL… ","date":"2023-08-26","objectID":"/oldroad-website/:1:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Demo Show simple function about this website. ","date":"2023-08-26","objectID":"/oldroad-website/:2:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Backend Function quick look A few infomations to help you get a good looking for the project: Login System - Allows users to log in and store data, saving persional informationand shopping cart contents. Shopping Cart - Enables users to create a wishlist. enhancing the overall shopping experience by allowing one-click ordering. Session Management - Facilitates seamless user interactions and data retention during their visit. Notidication - sends out notifications email to verify membership. ","date":"2023-08-26","objectID":"/oldroad-website/:3:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Frontend Adjust ","date":"2023-08-26","objectID":"/oldroad-website/:4:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"youtube I learned the usage of CSS and JavaScript on YouTube for the frontend, and then customized them into styles I personally prefer. ","date":"2023-08-26","objectID":"/oldroad-website/:4:1","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"stack overflow Fix the problem with guidance and expertise shared by the supportive Stack Overflow community. ","date":"2023-08-26","objectID":"/oldroad-website/:4:2","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"However However, I adjusted this part according to the actual circumstances. ","date":"2023-08-26","objectID":"/oldroad-website/:4:3","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Learning ","date":"2023-08-26","objectID":"/oldroad-website/:5:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Node.js, Express, and MongoDB First of all, This project was not just about building a website, it was a testament to the potency of my acquired skills and the limitless potential of continuous learning. As I dived into the intricacies of Node.js, I was captivated by its event-driven architecture. Express, serving as the backbone, streamlined the development process and allowed me to focus on crafting remarkable features. MongoDB, a NoSQL database, brought agility to data management, enabling seamless interactions between the application and the ever-expanding inventory. ","date":"2023-08-26","objectID":"/oldroad-website/:5:1","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Brain storming - process The process was a fusion of self-guided learning and hands-on experience. I started to think what users require and how the bussiness models of those major brands were constructed. what kind of services are important to establish on the website. ","date":"2023-08-26","objectID":"/oldroad-website/:5:2","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Retrospect In retrospect, this achievement has force my foundation as a developer. My E-commerce creation not only showcases products but also embodies the culmination of hours spent learning. ","date":"2023-08-26","objectID":"/oldroad-website/:5:3","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Architecture of folder ./OldroadWebsite ├── config ├── controllers ├── hero ├── middleware ├── model ├── photo ├── router ├── views ","date":"2023-08-26","objectID":"/oldroad-website/:6:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["project"],"content":"Source code my github repo Guide if you want to try this website, enter the github repo, I write about the How to run. ","date":"2023-08-26","objectID":"/oldroad-website/:7:0","tags":null,"title":"oldroad - 購物網站","uri":"/oldroad-website/"},{"categories":["Documents"],"content":"compare sql vs nosql database","date":"2023-08-31","objectID":"/sql-vs-nosql/","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"在後端工程領域，我們經常需要存儲和處理數據。 NoSQL和DBMS是兩種不同的數據存儲和管理方法，各有其優點和缺點。今天讓我們深入瞭解它們之間的區別。 此文章的重點會比較放在差異上。 banner ","date":"2023-08-31","objectID":"/sql-vs-nosql/:0:0","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Common Databases SQL是一種語法，NoSQL也就是不使用語法的資料庫。 而常見的DBMS - 關聯型數據庫管理系統通常都會聽到MySQL和postgres。 而NoSQL則是Mongodb了，小弟我的第一個專案使用的就是Mongodb 大家通常也常拿這兩家database比較。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:1:0","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"SQL Feature ","date":"2023-08-31","objectID":"/sql-vs-nosql/:1:1","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"sql syntax 我們常用的語法不外乎就是以下幾種： Note INSERT UPDATE SELECT DELETE DROP CREATE TRUNCATE 方便的是語法的結構大致是不變的，你可以理解成文法大部分是相同的，至少比學英文簡單多了。 假設我需要獲得使用者id=1的名字跟email： select name, email from customers where id =1; 更新特定users的電話號碼： update customers set phone_number = '123-456-7890' where id = 1; ","date":"2023-08-31","objectID":"/sql-vs-nosql/:1:2","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Data structure 的不同 當你了解這兩種資料結構的不同後，你就可以發現它們各自的優勢，也並沒有誰是真正所謂比較好的資料庫 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:2:0","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"DBMS 這些資料都會是以row and column的方式儲存在資料中 而這些data會利用**key**與彼此有關聯，像是foreign, primary key讓這些資料串接起來已協助我們搜尋資料。 於是我們就可以利用where,join on, count, sum…等等方式搭配index得到我們想要的資料。 這也是為什麼我們會稱之為關聯型資料庫。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:2:1","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Unstructured Data 非結構化數據 - unstructured data，沒有明確的數據結構形式。 你可以依照json格式塞入任何你想要的形式，且也不用每個資料有著一樣column或row，這給了noSQL極大的靈活性。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:2:2","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Key-Value 相對來看NoSql就簡單多了，他並沒有所謂的index, column以上雜七雜八的東西。 事實上，他就是一種資料結構的database，你可以把它當作key-value的儲存方式，而不是table的形式，當然這只是一種，但也是最常見的一種。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:2:3","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Redis Example redis 是一個key-value的non-sql資料庫，通常拿來當作in-memory database，拿來儲存一些你會需要快速可以獲取的資料，或是你為了減少server請求的來儲存資料，同時這些資料就算丟失也無傷大雅的內容。 當我載入一個圖片很多的網站，如果我沒有把資料塞到CACHE中，那每次登入此頁面的時候就會要重新拿取一次，試想你每次開啟ig都要等個5秒，那使用者還不揍你。 於是我們就會需要將圖片儲存起來如果10分鐘內有人同樣對同個網頁發送請求，那我就只需要： $redis = new Redis(); $key = 'unique_key_about_images'; $image = $redis-\u003eget($key); // or if(isset($keyValueStorage[$key])){ //直接透過keyvlue回傳 $image = $keyValueStorage[$key]; }else{ //去往server端發送請求拿圖片 $image = $server-\u003egetImage(); } 那你可能會好奇那我就都用key-value的方式儲存就好，反正這麼好用，我下面會舉個SQL優勢的例子： ","date":"2023-08-31","objectID":"/sql-vs-nosql/:2:4","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Query與資料結構的關聯性 如果今天要處理我想要一次對多個table做資料搜集該怎麼做。 如果是key-value的資料結構，我需要把所有table都拿需要的資料出來再整理。 但sql可以透過table關聯的index去簡化整個流程。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:2:5","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"SQL Example Note 如果我今天要處理每個部門的平均薪資： 假設有下面幾個表: 員工表(Employees):記錄員工信息 部門表(Departments):記錄部門信息 工資表(Salaries):記錄員工工資信息 查詢每個部門的平均工資,可以這樣寫SQL語句: SELECT d.dept_name, AVG(s.salary) AS avg_salary FROM Employees e JOIN Departments d ON e.dept_id = d.dept_id JOIN Salaries s ON e.emp_id = s.emp_id GROUP BY d.dept_name 這條SQL語句實現了以下功能： 從員工表、部門表和薪資表中get數據 通過員工表e的dept_id欄位和部門表d的dept_id欄位join兩個表 同時通過員工表的emp_id和工資表的emp_id聯結 從部門表d中選擇dept_name欄位 從工資表中選擇工資欄位計算mysql，起別名為avg_salary 根據部門名稱dept_name對結果分組 那麼這條語句得到的結果是： 每個部門的平均工資，總共會返回部門數量總計條記錄，每條記錄包括部門名稱和該部門的平均工資。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:2:6","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Compare to Different Statements 剛剛只是資料搜尋的部分 所以你真的很難去說sql比較好或是甚至是新手比較適合什麼等等 所以我想要再提幾個有關sql的點 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:3:0","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"更嚴謹的資料型態 Structured Data的好處可以強制資料型態為何！！ 這點很重要因為當我們在一個團隊裡做事的時候，常會遇到習慣不同的同事 😆 不要小看這一點小時間，在協作過程中這可以節省極大的時間來溝通。 當我們去閱讀前人寫的code的時候，使用DBMS可以明確的知道每個column該放什麼樣的資料，以及每個資料之間的關聯性為何，也可以創建更嚴謹的資料。 但同時也會需要更複雜的query，但有可能更快 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:3:1","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Writing And Reading 但如果我們今天的需求會需要快速開發： no-sql query依照資料型態的複雜度，可能會讓我們的query變慢 但同時可以讓工程師設計以及coding的時間縮短 但反之reading的部分就會相對來說是未來有可能的雷區。 json的名稱大小寫，value該存array還是int 如果有需要儲存時間，那他的資料格式會不會有insert的時候不同的情況。 …等等 (當然也有可能寫得很好，一切都是相對) Warning sql 可能會在設計或query的寫法比較複雜，但時間大部分來說會比較快。 no-sql在大部分來說設計的時候會相對快，query寫法簡單但效率較慢，閱讀起來也說不定會比較困難一些。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:3:2","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Connection 問題 用戶連接時 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:3:3","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"No-SQL - Connect no-sql比較好handle用戶連接數高的情況 不管是用戶寫入或讀取資料在no-sql這方便是一大優勢。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:3:4","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"SQL - Connect sql相對來說就比較需要去避免用戶對db的操作 更不用說有可能會有大量數據的訪問或是高複雜的Query 都有可能會造成DB崩潰或是卡死。 所以可能會需要連線池或是load balancer之類的功能協助減少對DB的過載。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:3:5","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Across Multiple Different Servers 許多No-sql Database也較擅長在不同的server中進行擴展。 如果你需要在不同的Server中同步你的資料，那no-sql是相對來說比較有優勢的。 Tip sql在建立table時還會需要去建立Index，所以sql也會更適合垂直擴展。 (當然水平擴展也可以，只是方法不同，並沒有一定也沒有哪個一定比較好。) sql資料結構的複雜性以及一致性，會導致相比no-sql複製資料來說比較有優勢。 But 如果你有比較特殊的需求或是query那sql至少可以不會因為query造成你的database loading ","date":"2023-08-31","objectID":"/sql-vs-nosql/:3:6","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"後話 雖然我都拿json來舉例，但事實上你也可以在column中存取json 也可以利用sql語法對json中的內容做操作 但當然要考慮資料庫正規化的內容 甚至你可以兩種sql and no-sql 都用也可以 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:4:0","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Simple Compare Note 🪣 NoSQL數據庫： ✔️ 靈活性：NoSQL數據庫以鍵值對、文檔、列和圖形等形式存儲數據，適用於各種數據結構。 ✔️ 擴展性：易於水平擴展，可以處理大量數據和高負載。 ❌ 一致性：在某些情況下，一致性可能較弱，取決於所選擇的NoSQL數據庫類型。 📖 DBMS（關聯型數據庫管理系統）： ✔️ 一致性：嚴格的一致性，確保數據完整性和一致性。 ✔️ 複雜查詢：支持複雜的SQL查詢，適用於需要多表關聯的場景。 ❌ 靈活性：對於半結構化數據，可能需要複雜的模式更改。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:5:0","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"總結 NoSQL適用於需要高度靈活性和可擴展性的場景，如大數據和實時數據處理。然而，DBMS在需要強一致性和複雜查詢的傳統業務應用中表現出色。 無論您選擇哪種數據存儲方法，都需要根據項目需求和性能目標進行明智的選擇。 ","date":"2023-08-31","objectID":"/sql-vs-nosql/:5:1","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["Documents"],"content":"Thinking 許多事情跟標準都是人們訂出來的，我認為要有能夠動態思考且不被框架限制住的思維，才更為重要。 很多觀念或是人們現在認為是 『用這個很好』 的經驗，都有可能在明天因為某個大神寫的新的工具而改變。 Thanks for watching ","date":"2023-08-31","objectID":"/sql-vs-nosql/:6:0","tags":["sql","nosql","淺談","DBMS"],"title":"SQL vs NoSQL 資料庫的選擇","uri":"/sql-vs-nosql/"},{"categories":["project"],"content":"Send sms notification by crawler tool with python. ","date":"2023-08-27","objectID":"/sms-python-gogoro/:0:0","tags":null,"title":"First project - automator tool","uri":"/sms-python-gogoro/"},{"categories":["project"],"content":"前言 此專案是我在進入軟體工程前製作的小工具，當時我只有對於program只有基本的邏輯判斷寫法，經驗只有大學用arduino自動化設備，like: 熱感應燈、熱感應風扇。 人們經過時會自動亮燈或是溫度太高開啟風扇的自動化設備。 使專案是我在gogoro實習時已經上手且想實現更多價值，於是試著思考如果`創造實際收益`或是`減少成本耗損`，提高廠內運轉速度以及工位周轉率，開發自動化發送簡訊的輔助工具。 illustative diagram ","date":"2023-08-27","objectID":"/sms-python-gogoro/:1:0","tags":null,"title":"First project - automator tool","uri":"/sms-python-gogoro/"},{"categories":["project"],"content":"Project ","date":"2023-08-27","objectID":"/sms-python-gogoro/:2:0","tags":null,"title":"First project - automator tool","uri":"/sms-python-gogoro/"},{"categories":["project"],"content":"Profit 節省30-40萬/年 Info 已該店實際工程師營收時薪計算，以及工作經驗實際平均評估， 有公定的收費時薪計算方式，以此分析。 ","date":"2023-08-27","objectID":"/sms-python-gogoro/:2:1","tags":null,"title":"First project - automator tool","uri":"/sms-python-gogoro/"},{"categories":["project"],"content":"Environment python3.11.4 Selenium ","date":"2023-08-27","objectID":"/sms-python-gogoro/:2:2","tags":null,"title":"First project - automator tool","uri":"/sms-python-gogoro/"},{"categories":["project"],"content":"How it works 依照輸入客戶電話也可以自動根據隔日預約名單，利用簡易爬蟲讀取第三方call api已達到發送簡訊內容。 內容有基本的模板，也可以由客戶端維修工程師或櫃檯服務人員自定義。 By inputting the customer’s phone number, the system can automatically retrieve the next day’s appointment list. It utilizes a simple web crawler to call third-party API, enabling the sending of SMS notifications. The messages follow a basic template but can also be customized by the client, maintenance engineers, or front desk personnel. ","date":"2023-08-27","objectID":"/sms-python-gogoro/:2:3","tags":null,"title":"First project - automator tool","uri":"/sms-python-gogoro/"},{"categories":["project"],"content":"Github source code source code link ","date":"2023-08-27","objectID":"/sms-python-gogoro/:2:4","tags":null,"title":"First project - automator tool","uri":"/sms-python-gogoro/"},{"categories":null,"content":"Fun fact about me.","date":"2023-08-26","objectID":"/about/","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":" Abstract Welcome to my personal blog! Here i’ll be sharing insights about my experience as a software engineer. i like to keep things simple and relatable. if you have any questions or any job oppertunities related to engineering. please contact me, let’s have a chat. By Adi. ","date":"2023-08-26","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"about me ","date":"2023-08-26","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Introduction Hi, 我是Adi，我目前從事軟體工程師一年以上的時間，主要負責的工作是後端工程師，現在從事的項目是遊戲server維護以及開發新功能，善於團隊合作針對需求以及不同的產品設計不同的server service，陸陸續續將會更新到posts。 ","date":"2023-08-26","objectID":"/about/:1:1","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Blog 2023-8-27 開始決定經營blog，主要的原因是想要有個自己的網站可以紀錄個人的Change log，也記下自己在當工程師的每個階段里程碑，過一段時間確認自己的方向是否為自己希望的Envisioned Life，另一方面想增進自己統整以及寫blog能力，在吸收到新的知識後，透過寫blog釐清自己的觀念，以及紀錄實用面的觀念，在未來快速找到工具使用。 之前也有開發AI server處理ai事務，舉例：pre-commit-msg case…等，我意識到我的日常類似統整或是翻譯事項已經開始交給AI處理，為了培養統整以及優化自己本身的溝通能力，利用blog的方式持續進步。 ","date":"2023-08-26","objectID":"/about/:1:2","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Work with me 易維護且易擴充服務 產品上線後，為了產品的生命週期，會需要對產品做維護以及開發更多可用功能，在設計之初就要儘量滿足未來的各式考量，具有開發多個產品會需要針對不同接口的服務。 團隊合作 在發開產品的主要雛形透過團隊或是自身開發，在未來後續團隊接手的學習成本也是重要的一環，從溝通討論共識 到後期的文件處理，都可以有效減低新進人員的上手時間。 自動化流程 礙於產品開發時程，構思提高開發效率方法，已開發多個能夠提高團隊開發速度工具，以及自動化測試流程，整合測試工具，建構自動化提升團隊開發效率，不需要讓團隊浪費重複且繁瑣的工作，舉例 AI Server後期也處理改版文件的統整。 ","date":"2023-08-26","objectID":"/about/:1:3","tags":null,"title":"About","uri":"/about/"}]